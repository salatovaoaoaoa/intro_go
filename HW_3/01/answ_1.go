//GOMAXPROCS - функция, которая устанавливает кол - во ядер (не реальных), на которых будет выполнятьтся программа
//мы не можем гарантровать одинаковый вывод при работе функции при использовании goрутин
// но если мы поставим 1 ядро, наш вывод всегда будет начинаться с 8ки

// Почему, когда я выставляю runtime.GOMAXPROCS(4), то порядок выполнения может быть любым:

//                            Почему, КОЛЯ? 3
//                            Почему, КОЛЯ? 0
//                            Почему, КОЛЯ? 8
//                            Почему, КОЛЯ? 4
//                            Почему, КОЛЯ? 2
//                            Почему, КОЛЯ? 5
//                            Почему, КОЛЯ? 6
// Паника

// А если выставляю runtime.GOMAXPROCS(1)
// То всегда будет начинаться:

// Почему, КОЛЯ? 8

package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	runtime.GOMAXPROCS(4)
	wg := sync.WaitGroup{}
	wg.Add(7)
	for i := 0; i < 9; i++ {
		i := i
		go func(i int) {
			defer wg.Done()
			fmt.Println("                           Почему, КОЛЯ?", i)
		}(i)
	}
	wg.Wait()

	// time.Sleep(1 * time.Second)
	fmt.Println("Паника")
}

// Ответ:

// При GOMAXPROCS > 1 /(Параметр GOMAXPROCS указывает, сколько потоков ОС необходимо использовать для
// одновременного исполнения кода Go. По умолчанию это значение равно количеству ядер ЦП на компьютере.)/
// горутины будут (могут) выполняться параллельно на нескольких потоках.
// То есть добавляются в очередь планировщика, который распределяет их выполнение по доступным потокам.
// У нас будет конкуренция между потоками — каждый поток может быть выполнен в разное время в зависимости от того,
// как работает планировщик Go и операционная система. Поэтому у нас порядок становится неопределенным.

// Инетерснее всего при GOMAXPROCS = 1.
// Тогда у нас имеется только один поток и все горутины будут выполняться на этом потоке,
// их порядок опять же определяется планировщиком.
// Он будет переключаться между горутинами только после того, как текущая горутина завершит выполнение или встанет
// на паузу.

// В нашем коде по завершении цикла for все 8 горутин попадают в очередь планировщика, ожидая выполнения.
// Видимо, в новых версиях Go планировщик устроен так, что он всегда запускает последнюю горутину первой.
// Думаю, это как - то связано с оптимизацией компилятора или оптимизациями Go runtime.

// Хотя сначала я подумала, что работает типа как стека (будет запущен первый поток из созданных
// - с цифрой 8, так как он был создан последним.), но нигде  этому подтверждение не нашла, поэтому только догадки
