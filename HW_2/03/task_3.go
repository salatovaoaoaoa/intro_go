// Задача с лекции: почему выводится в порядке:
// tryTest
// Второе время 2024-12-29 20:12:54.744985 +0300 MSK m=+2.001134210
// tryTest2
// Первое время: 2024-12-29 20:12:52.743986 +0300 MSK m=+0.000038501
//Подсказка: defer каким - то образом запоминает аргументы на момент его вызова

// Сама формулировка:
// 1. Объяснить вывов при defer tryTest()()
// 2. Объяснить вывод при defer tryTest()

package main

import (
	"fmt"
	"time"
)

func tryTest() func() {
	fmt.Println("tryTest")
	return func() {
		fmt.Println("tryTest2")
	}
}

func main() {
	defer fmt.Println("Первое время:", time.Now())
	defer tryTest()()
	time.Sleep(2 * time.Second)
	defer fmt.Println("Второе время", time.Now())

}

// Основное: код с defer будет выполняться в обратном порядке (то есть последний добавленный defer выполнится первым).
// Когда вызываем defer tryTest()(), то tryTest() выполняется СРАЗУ, но возвращённая функция откладывается
// на конец выполнения.
// То есть вызывается tryTest(), и в результате выполнения печатается tryTest.
// При этом возвращённая анонимная функция откладывается.

// Затем разматываем defer в обратном порядке:
// 1. Сначала выполняется defer Второе время
// 2. Затем выполняется отложенная функция, возвращённая из tryTest(): это tryTest2.
// 3. И только потом самый первый defer: Первое время

// А вот если бы был просто defer tryTest(), то tryTest() бы вызвался СРАЗУ, но возвращённая функция не вызвалась бы.
// Это работало бы как вызов tryTest, и никакой отложенной функции в defer не осталось бы.
